### 事件处理

> 直接把 JavaScript 代码写在 v-on 指令中是不可行的。因此 v-on 还可以接收一个需要调用的方法名称。
>
> 在内联语句处理器中访问原始的 DOM 事件,可以用特殊变量 $event 把它传入方法

```jsx
<div id="app">
    <div id="example-1">
        <button v-on:click="counter += 1"> 数值 :  {{ counter }} </button><br />
        <button v-on:dblclick="greet('abc', $event)">Greet</button>
        <!-- dblclick 双击 -->
    </div>
</div>
<script type="text/javascript">
var vm = new Vue({
    el : "#app",
    data : {
        counter: 0,
        name : "vue"
    },
    methods:{
        greet : function (str, e) {
            alert(str);
            console.log(e);
        }
    }
});
</script>
```

- 事件修饰符

```jsx
<!-- 阻止单击事件继续传播 -->
<a v-on:click.stop="doThis"></a>

<!-- 提交事件不再重载页面 -->
<form v-on:submit.prevent="onSubmit"></form>

<!-- 修饰符可以串联 -->
<a v-on:click.stop.prevent="doThat"></a>

<!-- 只有修饰符 -->
<form v-on:submit.prevent></form>

<!-- 添加事件监听器时使用事件捕获模式 -->
<!-- 即内部元素触发的事件先在此处理，然后才交由内部元素进行处理 -->
<div v-on:click.capture="doThis">...</div>

<!-- 只当在 event.target 是当前元素自身时触发处理函数 -->
<!-- 即事件不是从内部元素触发的 -->
<div v-on:click.self="doThat">...</div>

<!-- 点击事件将只会触发一次 -->
<a v-on:click.once="doThis"></a>
```

> 用 v-on:click.prevent.self 会阻止所有的点击，而 v-on:click.self.prevent 只会阻止对元素自身的点击。所以顺序很重要

### 表单输入绑定

> 可以用 v-model 指令在表单 input、textarea 及 select 元素上创建双向数据绑定。它会根据控件类型自动选取正确的方法来更新元素。v-model 本质上是语法糖。它负责监听用户的输入事件以更新数据，并对一些极端场景进行一些特殊处理。
>
>v-model 在内部为不同的输入元素使用不同的属性并抛出不同的事件：
>
> - text 和 textarea 元素使用 value 属性和 input 事件；
> - checkbox 和 radio 使用 checked 属性和 change 事件；
> - select 字段将 value 作为 prop 并将 change 作为事件。

```jsx
<div id="app">
    <div id="example-1">
        <input v-model="message" placeholder="edit me">
        <p>Message is: {{ message }}</p>
        <textarea v-model="message2" placeholder="add multiple lines"></textarea>
        <p style="white-space: pre-line;">{{ message2 }}</p>
        <br />
        
        <div style="margin-top:20px;">
            <input type="checkbox" id="zhao" value="zhao" v-model="checkedNames">
            <label for="zhao">zhao</label>
            <input type="checkbox" id="qian" value="qian" v-model="checkedNames">
            <label for="qian">qian</label>
            <input type="checkbox" id="sun" value="sun" v-model="checkedNames">
            <label for="sun">sun</label>
            <br>
            <span>Checked names: {{ checkedNames }}</span>
        </div>
        
        <div style="margin-top:20px;">
            <input type="radio" id="one" value="One" v-model="picked">
            <label for="one">One</label>
            <br>
            <input type="radio" id="two" value="Two" v-model="picked">
            <label for="two">Two</label>
            <br>
            <span>Picked: {{ picked }}</span>
        </div>
        <button type="button" @click="submit">提交</button>
    </div>
</div>
<script type="text/javascript">
var vm = new Vue({
    el : "#app",
    data : {
        message : "test",
        message2 :"hi",
        checkedNames : ['qian','sun'],//选中的值
        picked : "Two"
    },
    methods: {
        submit : function () {//获取表单中的值
            console.log(this.message);
            var postVal = {
                msg1:this.message,
                msg2:this.message2,
                checkVal:this.checkedNames,
                pickVal:this.picked
            }
            console.log(postVal);
        }
    }
});
</script>
```

### 组件基础

> 组件是可复用的 Vue 实例。
> 
> 与 new Vue 接收相同的选项。
> 
> 组件可以进行任意次数的复用.


```jsx
<div id="app">
    <button-counter title="title1 : " @clicknow="clicknow">
        <h2>hi...h2</h2>
    </button-counter>
    <button-counter title="title2 : "></button-counter>
    <!-- 每个组件都会各自独立维护它的 count。因为你每用一次组件，就会有一个它的新实例被创建。 -->
</div>
<script type="text/javascript">
//创建组件
Vue.component('button-counter', {
    props: ['title'],
    data: function () {
        return {
            count: 0
        }
    },
    //组件模板,使用多个标签要包裹在一个标签中
    template: '<div><h1>hi...</h1><button v-on:click="clickfun">{{title}} You clicked me {{ count }} times.</button><slot></slot></div>',
    methods:{
        clickfun : function () {
            this.count ++;
            //通过emit方法出发clicknow函数
            this.$emit('clicknow', this.count);//事件名称,可携带的参数
        }
    }
})
var vm = new Vue({
    el : "#app",
    data : {
        
    },
    methods:{
        clicknow : function (e) {
            console.log(e);
        }
    }
});
</script>
```

### 组件注册

>一个组件的 data 选项必须是一个函数.
> 
> 组件命名：短横线分割法（my-component-name）、驼峰法（MyComponentName)
>
> Vue.component 创建的组件是全局注册的。它们在注册之后可以用在任何新创建的 Vue 根实例 (new Vue) 的模板中。
>
> 局部注册的组件在其子组件中不可用.

```jsx
<div id="app">
	<button-counter></button-counter>
	<test></test>
</div>
<script type="text/javascript">
//全局注册
Vue.component('button-counter', {
	props: ['title'],
	data: function () {
		return {}
	},
	template: '<div><h1>hi...</h1></div>',
	methods:{
		
	}
})
var vm = new Vue({
	el : "#app",
	data : {
		
	},
	methods:{
		clicknow : function (e) {
			console.log(e);
		}
    },
    //局部注册
	components:{
		test : {
			template:"<h2>h2...</h2>"
		}
	}
});
</script>
```

### 单文件组件

- 在很多 Vue 项目中，我们使用 Vue.component 来定义全局组件，紧接着用 new Vue({ el: '#container '}) 在每个页面内指定一个容器元素。

这种方式在很多中小规模的项目中运作的很好，在这些项目里 JavaScript 只被用来加强特定的视图。但当在更复杂的项目中，或者你的前端完全由 JavaScript 驱动的时候，下面这些缺点将变得非常明显：

> - 全局定义 (Global definitions) 强制要求每个 component 中的命名不得重复
> - 字符串模板 (String templates) 缺乏语法高亮，在 HTML 有多行的时候，需要用到丑陋的 \
> - 不支持 CSS (No CSS support) 意味着当 HTML 和 JavaScript 组件化时，CSS 明显被遗漏
> - 没有构建步骤 (No build step) 限制只能使用 HTML 和 ES5 JavaScript，而不能使用预处理器，如 Pug (formerly Jade) 和 Babel

所以引入了文件扩展名为 .vue 的 single-file components(单文件组件) 。

- 安装 `npm`

`npm` 全称为 `Node Package Manager`，是一个基于`Node.js`的包管理器，也是整个`Node.js`社区最流行、支持的第三方模块最多的包管理器。

```
npm -v
```

- 由于网络原因 安装 `cnpm`

```
npm install -g cnpm --registry=https://registry.npm.taobao.org
```

- 安装 `vue-cli`

```
cnpm install -g @vue/cli
```

- 安装 `webpack`

`webpack` 是  `JavaScript` 打包器(module bundler)

```
cnpm install -g webpack
```